# Linker script documentation

Linker script instruct linker on how to assemble final binary file (which is flashed to MCU) from object files generated by compiler. This file documents linker script `stm32f030x8.ld`.

## Memory layout section

[Link to documentation](https://sourceware.org/binutils/docs/ld/MEMORY.html)

Defines types of memory. Names (ram, rom) are arbitrary and user-defined. Attributes *rwx* signifies read-only/write/executable section. Throughout the script origin and length of the section can be accessed using `ORIGIN(name)` and `LENGTH(name)`.

For STM32F030xx flash (rom) and ram size are given as:

- FLASH memory size for STM32F030xx is given as:
    - 16  KB for STM32030x4
    - 32  KB for STM32030x6
    - 64  KB for STM32030x8
    - 256 KB for STM32030xC
- RAM size is given as:
    - 4  KB for STM32F030x4 and STM32F030x6
    - 8  KB for STM32F030x8
    - 32 KB for STM32F030xC

```
MEMORY
{
  rom (rx)  : ORIGIN = 0x08000000, LENGTH = 64K
  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 8K
}
```

## Stack location

In this case, initial stack pointer value is the address of the end of ram (stack grows 'down' to lower addresses with each *push* instruction). Symbol *_estack* is used in *src/startup_stm32f030x.c*.

Note that Cortex-M has banked stack pointer: MSP (master stack pointer) and PSP (process stack pointer). MSP is used by default. You don't need to concern yourself with this fact if you don't intend to implement some kind of RTOS/scheduler (it's perfectly okay to just work with MSP).

```
_estack = ORIGIN(ram) + LENGTH(ram); /* ram end */
```

Note that this is only symbol assignment, name of the symbol (`_estack`) is arbitrary.

## Sections

Output sections have general form of (see [ld documentation](https://sourceware.org/binutils/docs/ld/Output-Section-Description.html)):

```
section [address] [(type)] :
  [AT(lma)]
  [ALIGN(section_align) | ALIGN_WITH_INPUT]
  [SUBALIGN(subsection_align)]
  [constraint]
  {
    output-section-command
    output-section-command
    …
  } [>region] [AT>lma_region] [:phdr :phdr …] [=fillexp] [,]

```

`output-section-command` may be:

* symbol assignment
* input section definition
* data values to include directly
* special output section keyword

### Input section definition

Has general form of FILE(.SECTION.SUBSECTION). Wildcards can be used. E.g. `*(.text*)` stands for *every .text.XXX section in every file*

```
SECTIONS
{
	.text :
	{
		KEEP(*(.stack_init_value))
		KEEP(*(.isr_vector_table))
		*(.text*)
		*(.rodata*)
		_etext = .;

	} > rom

	.data : AT(_etext)
	{
		_sdata = .;
		*(.data*)
		_edata = .;

	} > ram

	.bss (NOLOAD):
	{
		_sbss = .;
		*(.bss*)
		*(COMMON)
		_ebss = .;
	} > ram
}
```

Few notes:

* `KEEP( )` instructs linker not to remove the section when link-time garbage collection is active (argument `--gc-sections`)
* `.` stands for current address. Address counter is incremented with each section. Meaning in the code above, `_etext` will be the address one byte after the last byte of .text section. Effectively end of .text + 1
* Since linker operates with two addresses (LMA and VMA), two counters are effectively used: `_etext` is LMA address and `_edata` is VMA address. What address is used is decided according to what memory current section belongs (section ends with `} > ram` or `} > rom`)
* e.g. data section is:
	* stored in rom (LMA address), this is instructed using `AT(_etext)`, meaning data should be stored in flash right after the end of text section
	* loaded during startup (`Reset` handler) from rom to ram (LMA to VMA)
	* located in ram during execution of application
* `NOLOAD` instruct linker that this section is not to be loaded (uninitialized variables do not actually take space in binary file, they are runtime-created)
* `COMMON` is just another section with unitialized variables, often created by compilers
